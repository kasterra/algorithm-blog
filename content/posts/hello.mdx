---
title: sample title
date: 2025-08-22
summary: "A gentle introduction to the two-pointer pattern with classic examples. "
category: "Arrays & Strings"
tags:
  - two-pointers
  - patterns
  - arrays
readTime: "5 min"
difficulty: Easy
---

The two-pointer technique is one of the most elegant and efficient approaches for solving array and string problems. This pattern involves using two pointers that traverse the data structure in a coordinated manner, often leading to optimal O(n) time complexity solutions.

## Understanding the Two-Pointer Pattern

The two-pointer technique works by maintaining two references (pointers) to elements in an array or string. These pointers can move:
- **Towards each other** (convergent approach)
- **In the same direction** (sliding window approach)
- **At different speeds** (fast and slow pointers)

## Classic Problem: Two Sum in Sorted Array

Let's start with a fundamental example. Given a sorted array and a target sum, find two numbers that add up to the target.

```python
def two_sum_sorted(nums, target):
    """
    Find two numbers in a sorted array that sum to target.
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(nums) - 1
    
    while left < right:
        current_sum = nums[left] + nums[right]
        
        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1  # Need larger sum
        else:
            right -= 1  # Need smaller sum
    
    return []  # No solution found

# Example usage
nums = [2, 7, 11, 15]
target = 9
result = two_sum_sorted(nums, target)
print(f"Indices: {result}")  # Output: [0, 1]
```

The beauty of this approach lies in its simplicity and efficiency. By leveraging the sorted property, we can make intelligent decisions about which pointer to move.

## Advanced Example: Container With Most Water

Here's a more complex problem that demonstrates the power of two pointers:

```javascript
function maxArea(height) {
    /**
     * Find the container that can hold the most water
     * Time: O(n), Space: O(1)
     */
    let left = 0;
    let right = height.length - 1;
    let maxWater = 0;
    
    while (left < right) {
        // Calculate current area
        const width = right - left;
        const currentHeight = Math.min(height[left], height[right]);
        const currentArea = width * currentHeight;
        
        maxWater = Math.max(maxWater, currentArea);
        
        // Move the pointer with smaller height
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxWater;
}

// Example
const heights = [1, 8, 6, 2, 5, 4, 8, 3, 7];
console.log(maxArea(heights)); // Output: 49
```

## Key Insights and Best Practices

### When to Use Two Pointers

1. **Sorted arrays or strings** - The sorted property enables intelligent pointer movement
2. **Finding pairs or triplets** - Especially when looking for specific sums
3. **Palindrome problems** - Compare characters from both ends
4. **Removing duplicates** - Maintain unique elements efficiently

### Common Patterns

```cpp
// Pattern 1: Convergent pointers
int left = 0, right = n - 1;
while (left < right) {
    // Process current pair
    if (condition) {
        left++;
    } else {
        right--;
    }
}

// Pattern 2: Same direction (sliding window)
int slow = 0, fast = 0;
while (fast < n) {
    // Expand window
    fast++;
    
    // Contract window if needed
    while (window_invalid) {
        slow++;
    }
}
```

## Time and Space Complexity

The two-pointer technique typically achieves:
- **Time Complexity**: O(n) - single pass through the data
- **Space Complexity**: O(1) - only using two pointer variables

This is a significant improvement over brute force O(n²) approaches that check all pairs.

## Practice Problems

To master this technique, try solving these problems:

1. **Remove Duplicates from Sorted Array**
2. **Valid Palindrome**
3. **3Sum Problem**
4. **Trapping Rain Water**
5. **Sort Colors (Dutch National Flag)**

Each problem will help you recognize different variations of the two-pointer pattern and build your intuition for when to apply this technique.

## Conclusion

The two-pointer technique is a fundamental algorithmic pattern that every programmer should master. Its elegance lies in transforming complex O(n²) problems into efficient O(n) solutions through clever pointer manipulation. Practice with various problems to develop the intuition for recognizing when this pattern applies.

# Sample Here

```js index.js
function lorem(ipsum, dolor = 1) {
  const sit = ipsum == null ? 0 : 1
  dolor = sit - amet(dolor)
  return sit ? consectetur(ipsum) : []
}
```
HOHOHO

```js
const lorem = ipsum(dolor, sit)
// !callout[/amet/] This is a callout
const [amet, consectetur] = [0, 0]
lorem.adipiscing((sed, elit) => {
  if (sed) {
    amet += elit
  }
})
```
